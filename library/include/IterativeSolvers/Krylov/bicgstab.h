//********************************************************************************
//
// MIT License
//
// Copyright(c) 2024-2025 James Sandham
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this softwareand associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
//********************************************************************************

#ifndef BICGSTAB_H
#define BICGSTAB_H

#include "../../linalglib_export.h"

#include "../iter_control.h"
#include "../Preconditioner/preconditioner.h"

#include "../../vector.h"
#include "../../csr_matrix.h"

/*! \file
 *  \brief bicgstab.h provides interface for stabilized bi-conjugate gradient solver
 */

namespace linalg
{
/*! \brief A solver class implementing the Bi-Conjugate Gradient Stabilized (BiCGSTAB) method.
 *
 * \details
 * This class provides functionality to solve large, sparse, non-symmetric systems of linear
 * equations of the form \f$A \cdot x = b\f$ using the Bi-Conjugate Gradient Stabilized (BiCGSTAB)
 * iterative method. BiCGSTAB is a popular Krylov subspace method known for its robust
 * convergence properties for non-symmetric systems, often outperforming BiCG. It can be
 * used with or without a preconditioner.
 *
 * \section bicgstab_algorithm The BiCGSTAB Algorithm
 *
 * The BiCGSTAB algorithm seeks to find an approximate solution \f$\mathbf{x}\f$ to \f$A\mathbf{x} = \mathbf{b}\f$.
 * The core idea involves constructing two biorthogonal sequences of vectors: one from the
 * Krylov subspace generated by \f$A\f$ and another from the Krylov subspace generated by \f$A^T\f$.
 * The "stabilized" part aims to smooth out the typically erratic convergence behavior of BiCG.
 *
 * The non-preconditioned BiCGSTAB algorithm steps are:
 *
 * 1. **Initialize:**
 * Set initial guess \f$\mathbf{x}^{(0)}\f$.
 * Compute initial residual \f$\mathbf{r}^{(0)} = \mathbf{b} - A \mathbf{x}^{(0)}\f$.
 * Choose an arbitrary vector \f$\mathbf{r}_0\f$ such that \f$\mathbf{r}_0^T \mathbf{r}^{(0)} \neq 0\f$.
 * Often, \f$\mathbf{r}_0 = \mathbf{r}^{(0)}\f$ is chosen.
 * Set \f$\mathbf{p}^{(0)} = \mathbf{0}\f$, \f$\mathbf{v}^{(0)} = \mathbf{0}\f$.
 * \f$\rho_0 = 1\f$, \f$\alpha = 1\f$, \f$\omega_0 = 1\f$.
 *
 * 2. **Iterate** for \f$k = 0, 1, 2, \dots\f$ until convergence:
 * a. \f$\rho_k = \mathbf{r}_0^T \mathbf{r}^{(k)}\f$
 * b. \f$\beta = (\rho_k / \rho_{k-1}) \cdot (\alpha / \omega_k)\f$ (for \f$k>0\f$)
 * c. \f$\mathbf{p}^{(k)} = \mathbf{r}^{(k)} + \beta (\mathbf{p}^{(k)} - \omega_k \mathbf{v}^{(k)})\f$
 * d. \f$\mathbf{v}^{(k)} = A \mathbf{p}^{(k)}\f$
 * e. \f$\alpha = \rho_k / (\mathbf{r}_0^T \mathbf{v}^{(k)})\f$
 * f. \f$\mathbf{s} = \mathbf{r}^{(k)} - \alpha \mathbf{v}^{(k)}\f$
 * g. Check for convergence with \f$\mathbf{s}\f$. If converged, then \f$\mathbf{x}^{(k+1)} = \mathbf{x}^{(k)} + \alpha \mathbf{p}^{(k)}\f$ and exit.
 * h. \f$\mathbf{t} = A \mathbf{s}\f$
 * i. \f$\omega_{k+1} = (\mathbf{t}^T \mathbf{s}) / (\mathbf{t}^T \mathbf{t})\f$
 * j. \f$\mathbf{x}^{(k+1)} = \mathbf{x}^{(k)} + \alpha \mathbf{p}^{(k)} + \omega_{k+1} \mathbf{s}\f$
 * k. \f$\mathbf{r}^{(k+1)} = \mathbf{s} - \omega_{k+1} \mathbf{t}\f$
 * l. Check for convergence with \f$\mathbf{r}^{(k+1)}\f$.
 *
 * \subsection bicgstab_preconditioned Preconditioned BiCGSTAB
 *
 * For the preconditioned version, a preconditioner \f$M \approx A^{-1}\f$ is used. The algorithm
 * steps are modified by applying the preconditioner:
 *
 * 1. **Initialize:**
 * Set initial guess \f$\mathbf{x}^{(0)}\f$.
 * Compute initial residual \f$\mathbf{r}^{(0)} = \mathbf{b} - A \mathbf{x}^{(0)}\f$.
 * Choose an arbitrary vector \f$\mathbf{r}_0\f$ such that \f$\mathbf{r}_0^T \mathbf{r}^{(0)} \neq 0\f$.
 * Often, \f$\mathbf{r}_0 = \mathbf{r}^{(0)}\f$ is chosen.
 * Set \f$\mathbf{p}^{(0)} = \mathbf{0}\f$, \f$\mathbf{v}^{(0)} = \mathbf{0}\f$.
 * \f$\rho_0 = 1\f$, \f$\alpha = 1\f$, \f$\omega_0 = 1\f$.
 *
 * 2. **Iterate** for \f$k = 0, 1, 2, \dots\f$ until convergence:
 * a. \f$\rho_k = \mathbf{r}_0^T \mathbf{r}^{(k)}\f$
 * b. \f$\beta = (\rho_k / \rho_{k-1}) \cdot (\alpha / \omega_k)\f$ (for \f$k>0\f$)
 * c. \f$\mathbf{p}^{(k)} = \mathbf{r}^{(k)} + \beta (\mathbf{p}^{(k)} - \omega_k \mathbf{v}^{(k)})\f$
 * d. Solve \f$M \mathbf{z} = \mathbf{p}^{(k)}\f$ (preconditioning step)
 * e. \f$\mathbf{v}^{(k)} = A \mathbf{z}\f$
 * f. \f$\alpha = \rho_k / (\mathbf{r}_0^T \mathbf{v}^{(k)})\f$
 * g. \f$\mathbf{s} = \mathbf{r}^{(k)} - \alpha \mathbf{v}^{(k)}\f$
 * h. Check for convergence with \f$\mathbf{s}\f$. If converged, then \f$\mathbf{x}^{(k+1)} = \mathbf{x}^{(k)} + \alpha \mathbf{z}\f$ and exit.
 * i. Solve \f$M \mathbf{q} = \mathbf{s}\f$ (preconditioning step)
 * j. \f$\mathbf{t} = A \mathbf{q}\f$
 * k. \f$\omega_{k+1} = (\mathbf{t}^T \mathbf{s}) / (\mathbf{t}^T \mathbf{t})\f$
 * l. \f$\mathbf{x}^{(k+1)} = \mathbf{x}^{(k)} + \alpha \mathbf{z} + \omega_{k+1} \mathbf{q}\f$
 * m. \f$\mathbf{r}^{(k+1)} = \mathbf{s} - \omega_{k+1} \mathbf{t}\f$
 * n. Check for convergence with \f$\mathbf{r}^{(k+1)}\f$.
 *
 * \section bicgstab_convergence Convergence and Breakdowns
 *
 * BiCGSTAB often converges smoothly and quickly for a wide range of non-symmetric problems.
 * However, it can encounter breakdowns where \f$\mathbf{r}_0^T \mathbf{v}^{(k)} = 0\f$ (leading to division by zero for \f$\alpha\f$)
 * or \f$\mathbf{t}^T \mathbf{t} = 0\f$ (leading to division by zero for \f$\omega\f$). These are referred to as
 * breakdown situations. Strategies like restarting or switching to a different solver (e.g., GMRES)
 * can be employed to handle such cases.
 * The parameter `restart_iter` controls how often the solver is restarted with a fresh residual to avoid potential stagnation or breakdown.
 *
 * \section bicgstab_example Example Usage
 * Below is a simplified example demonstrating how to use the `bicgstab_solver` class
 * with and without a preconditioner. This assumes `csr_matrix`, `vector`, `preconditioner`,
 * and `iter_control` classes are properly defined and functional.
 *
 * \code
 * #include "linalglib.h"
 * #include <iostream>
 * #include <vector>
 *
 * int main() {
 * // Define a sample sparse matrix A (e.g., a non-symmetric one)
 * // A = [ 4 -1  0 ]
 * //     [ 1  4 -1 ]
 * //     [ 0  1  4 ]
 * std::vector<int> row_ptr = {0, 2, 5, 7};
 * std::vector<int> col_ind = {0, 1, 0, 1, 2, 1, 2};
 * std::vector<double> val = {4.0, -1.0, 1.0, 4.0, -1.0, 1.0, 4.0};
 *
 * int m = 3; // Number of rows
 * int n = 3; // Number of columns
 * int nnz = 7; // Number of non-zeros
 *
 * csr_matrix A(row_ptr, col_ind, val, m, n, nnz);
 *
 * // Define the right-hand side vector b
 * std::vector<double> b_data = {5.0, 6.0, 9.0};
 * vector b(b_data);
 *
 * // Define an initial guess for the solution vector x (e.g., all zeros)
 * vector x(m);
 * x.zeros();
 *
 * // Set up iteration control
 * iter_control control;
 * control.max_iterations = 200;
 * control.tolerance = 1e-7;
 *
 * // Create a BiCGSTAB solver instance
 * bicgstab_solver solver;
 *
 * // --- Non-preconditioned solve ---
 * std::cout << "--- Starting non-preconditioned BiCGSTAB solver ---" << std::endl;
 * vector x_nonprecond = x; // Copy initial guess
 * int status_nonprecond = solver.solve_nonprecond(A, x_nonprecond, b, control);
 *
 * if (status_nonprecond == 0) {
 * std::cout << "Non-preconditioned BiCGSTAB converged successfully!" << std::endl;
 * } else {
 * std::cout << "Non-preconditioned BiCGSTAB did NOT converge. Status code: " << status_nonprecond << std::endl;
 * }
 * std::cout << "Approximate solution x (non-preconditioned):" << std::endl;
 * for (int i = 0; i < x_nonprecond.get_size(); ++i) {
 * std::cout << "x[" << i << "] = " << x_nonprecond[i] << std::endl;
 * }
 *
 * // --- Preconditioned solve (e.g., with Jacobi preconditioner) ---
 * std::cout << "\n--- Starting preconditioned BiCGSTAB solver (Jacobi) ---" << std::endl;
 * jacobi_precond jacobi_prec;
 * jacobi_prec.build(A); // Build the preconditioner for matrix A
 *
 * vector x_precond = x; // Copy initial guess
 * int status_precond = solver.solve_precond(A, x_precond, b, &jacobi_prec, control);
 *
 * if (status_precond == 0) {
 * std::cout << "Preconditioned BiCGSTAB converged successfully!" << std::endl;
 * } else {
 * std::cout << "Preconditioned BiCGSTAB did NOT converge. Status code: " << status_precond << std::endl;
 * }
 * std::cout << "Approximate solution x (preconditioned):" << std::endl;
 * for (int i = 0; i < x_precond.get_size(); ++i) {
 * std::cout << "x[" << i << "] = " << x_precond[i] << std::endl;
 * }
 *
 * return 0;
 * }
 * \endcode
 */
class bicgstab_solver
{
private:
    /*! \brief Residual vector in the BiCGSTAB algorithm. */
    vector r;
    /*! \brief Initial residual vector, used for biorthogonality. */
    vector r0;
    /*! \brief Search direction vector. */
    vector p;
    /*! \brief Vector for \f$A \cdot \mathbf{p}\f$ or \f$A \cdot \mathbf{z}\f$ terms. */
    vector v;
    /*! \brief Vector for \f$A \cdot \mathbf{s}\f$ terms. */
    vector t;
    /*! \brief Intermediate vector for preconditioning: \f$M^{-1} \mathbf{p}\f$. */
    vector z;
    /*! \brief Intermediate vector for preconditioning: \f$M^{-1} \mathbf{s}\f$. */
    vector q;

    /*! \brief Number of iterations after which the solver should restart.
     * A value of 0 or a very large number typically means no restart.
     * Restarts can help to avoid potential breakdowns or loss of orthogonality.
     */
    int restart_iter;

public:
    /*! \brief Default constructor.
     * Initializes a new `bicgstab_solver` object.
     */
    bicgstab_solver();

    /*! \brief Destructor.
     * Cleans up any resources allocated by the `bicgstab_solver` object.
     */
    ~bicgstab_solver();

    /*! \brief Deleted copy constructor.
     * Prevents direct copying of `bicgstab_solver` objects to ensure proper memory management.
     */
    bicgstab_solver (const bicgstab_solver&) = delete;

    /*! \brief Deleted copy assignment operator.
     * Prevents direct assignment of one `bicgstab_solver` object to another to ensure proper memory management.
     */
    bicgstab_solver& operator= (const bicgstab_solver&) = delete;

    /*! \brief Builds necessary data structures for the BiCGSTAB solver.
     * \details
     * For BiCGSTAB, this typically involves allocating and resizing the internal
     * work vectors (`r`, `r0`, `p`, `v`, `t`, `z`, `q`) to match the dimensions
     * of the matrix `A`.
     * \param A The sparse matrix in CSR format for which the solver is being built.
     */
    void build(const csr_matrix& A);

    /*! \brief Solves the linear system \f$A \cdot x = b\f$ using the non-preconditioned BiCGSTAB method.
     *
     * This method implements the BiCGSTAB algorithm without any explicit preconditioning.
     * It iteratively refines the solution `x` until the convergence criteria from `control`
     * are met or the maximum number of iterations is reached.
     *
     * \param A The sparse coefficient matrix in CSR format.
     * \param x On input, an initial guess for the solution vector; on output, the computed solution vector.
     * \param b The right-hand side vector.
     * \param control An `iter_control` object that manages the iteration process,
     * including convergence tolerance and maximum iterations.
     * \return An integer status code:
     * - `0` if the solver converged successfully within the specified tolerance.
     * - `1` if the maximum number of iterations was reached without convergence.
     * - Negative values indicate potential breakdowns (e.g., division by zero due to loss of orthogonality).
     */
    int solve_nonprecond(const csr_matrix& A, vector& x, const vector& b, iter_control control);

    /*! \brief Solves the linear system \f$A \cdot x = b\f$ using the preconditioned BiCGSTAB method.
     *
     * This method implements the BiCGSTAB algorithm with the provided preconditioner.
     * It iteratively refines the solution `x` until the convergence criteria from `control`
     * are met or the maximum number of iterations is reached.
     *
     * \param A The sparse coefficient matrix in CSR format.
     * \param x On input, an initial guess for the solution vector; on output, the computed solution vector.
     * \param b The right-hand side vector.
     * \param precond A pointer to a `preconditioner` object to be used. The `build` method
     * of the preconditioner should have been called previously for matrix `A`.
     * \param control An `iter_control` object that manages the iteration process,
     * including convergence tolerance and maximum iterations.
     * \return An integer status code:
     * - `0` if the solver converged successfully within the specified tolerance.
     * - `1` if the maximum number of iterations was reached without convergence.
     * - Negative values indicate potential breakdowns or issues with the preconditioner.
     */
    int solve_precond(const csr_matrix& A, vector& x, const vector& b, const preconditioner *precond, iter_control control);

    /*! \brief Generic solve method for the BiCGSTAB solver (delegates to non-preconditioned or preconditioned).
     *
     * This method acts as a convenience wrapper. If `precond` is `nullptr`, it calls
     * `solve_nonprecond`. Otherwise, it calls `solve_precond`.
     *
     * \param A The sparse coefficient matrix in CSR format.
     * \param x On input, an initial guess for the solution vector; on output, the computed solution vector.
     * \param b The right-hand side vector.
     * \param precond A pointer to a `preconditioner` object to be used. If `nullptr`, no preconditioning is applied.
     * \param control An `iter_control` object that manages the iteration process,
     * including convergence tolerance and maximum iterations.
     * \return An integer status code, consistent with `solve_nonprecond` or `solve_precond`.
     */
    int solve(const csr_matrix& A, vector& x, const vector& b, const preconditioner *precond, iter_control control);
};
}

#endif
